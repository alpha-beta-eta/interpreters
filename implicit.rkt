#lang racket
(require "match.rkt" "env.rkt" "store.rkt")
;<exp> ::= <var>
;       |  <int>
;       |  (set! <var> <exp>)
;       |  (begin <exp> <exp>)
;       |  (lambda <var> <exp>)
;       |  (let <var> <exp> <exp>)
;       |  (<op> <exp> <exp>)
;       |  (<exp> <exp>)
;<op> ::= + | - | *
(define store (make-store 1000))
(define (newref val)
  (store 'newref val))
(define (deref ref)
  (store 'deref ref))
(define (setref ref val)
  (store 'setref ref val))
(define (interp exp env)
  (match exp
    (,var (guard (symbol? var)) (deref (apply-env env var)))
    (,int (guard (integer? int)) int)
    ((set! ,x ,e)
     (let* ((val (interp e env))
            (ref (apply-env env x)))
       (setref ref val)))
    ((begin ,e1 ,e2)
     (interp e1 env)
     (interp e2 env))
    ((lambda ,x ,body)
     (make-closure x body env))
    ((let ,x ,e ,body)
     (let* ((val (interp e env))
            (ref (newref val))
            (env^ (extend-env x ref env)))
       (interp body env^)))
    ((,op ,e1 ,e2)
     (guard (memq op '(+ - *)))
     (let* ((v1 (interp e1 env))
            (v2 (interp e2 env)))
       (case op
         ((+) (+ v1 v2))
         ((-) (- v1 v2))
         ((*) (* v1 v2)))))
    ((,rator ,rand)
     (let* ((closure (interp rator env))
            (arg (interp rand env))
            (ref (newref arg)))
       (apply-closure closure ref)))))
(define (make-closure x body env)
  `(closure ,x ,body ,env))
(define (apply-closure closure ref)
  (match closure
    ((closure ,x ,body ,env)
     (interp body (extend-env x ref env)))))